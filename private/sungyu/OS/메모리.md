# 메모리  

### 메모리 계층  

<img width="480" alt="IMG_0036-removebg-preview" src="https://github.com/user-attachments/assets/d66dbc1b-4725-48d5-8dbd-41323eab9c31" />

- **레지스터** : CPU 안에 있는 작은 메모리를 뜻하며, 속도가 가장 빠르고 기억 용량이 가장 적다. (휘발성)  
- **캐시** (L1, L2) : L1, L2 캐시를 지칭하며, 속도가 빠르고 기억 용량이 적다. (휘발성)  
- **주기억장치** (RAM) : RAM을 지칭하며, 속도, 기억 용량이 보통 수준이다. (휘발성)  
- **보조기억장치** (HDD, SSD) : HDD, SSD를 뜻하며, 속도가 느리고 기억 용량이 많다. (비휘발성)  

<br>

**메모리 계층의 목적** (=캐싱)  
**캐싱**(Cashing)을 이용하여 빠르고 작은 메모리와 크고 느린 메모리의 장점을 조합해서 크고 빠른 메모리처럼 활용하기 위해서  

<br>

### 캐시(Cache)  
> 데이터를 미리 복사해두는 임시 저장소이자, 빠른 장치와 느린 장치의 속도 차이에 따른 병목 현상을 줄이기 위한 메모리  

<br>

**CPU 와 메모리 간 성능 차이**  
<img width="606" height="324" alt="image" src="https://github.com/user-attachments/assets/7ba35071-e8fa-439b-8172-a043b2a15dda" />

- CPU는 데이터 처리를 위해 메모리와 끊임없이 데이터를 주고받는 구조  
- 메모리가 CPU의 데이터 처리 속도를 쫒아가지 못함  
- CPU가 메모리를 기다려야 하는 **병목현상** 발생

<br>

<img width="1439" height="627" alt="스크린샷 2026-01-29 05 24 37" src="https://github.com/user-attachments/assets/f2179a71-bba6-4936-8afd-9c30a17120a3" />  
Referenced : https://www.youtube.com/watch?v=JBFT4KyEvoY  

- 병목현상 완화를 위해 용량은 작지만 속도가 빠른 **캐시 메모리**를 배치  
- 향후 **재사용 가능성이 높은 데이터** 복사본을 저장 후 CPU 요청 시, 바로 전달  

<br>

**시간 지역성**  
> 최근에 사용했던 데이터에 다시 접근하려는 특성  

**공간 지역성**  
> 최근 접근한 데이터를 이루고 있는 공간 또는 그 인접한 공간에 접근하는 특성  

<br>

```java
for (i = 0; i < 3; i++) {
	data[i+1] = data[i] + 1;	// 시간 지역성
}

'''	공간 지역성
data[1] = data[0] + 1;
data[2] = data[1] + 1;
data[3] = data[2] + 1
'''
```

<br>
<br>

**캐시 히트**  
> 캐시 메모리에서 원하는 데이터를 찾은 경우  

**캐시 미스**  
> 캐시 메모리에 원하는 데이터가 없어 주메모리(RAM)로 가서 데이터를 찾아오는 경우  

**캐시 매핑**  
> 캐시가 히트되기 위해 매핑하는 방법  

- CPU (레지스터)와 주메모리(RAM) 간에 데이터를 주고 받을 때를 기준  

- **직접 매핑**(Directed mapping) : 캐시가 `1-10`, 메모리가 `1-100`이라면, `1:1-10`, `2:11-20` 이런식으로 매핑 -> 처리가 빠르지만 충돌 발생이 잦다.  
- **연관 매핑**(Associative mapping) : 순서를 일치시키지 않고 관련있는 캐시와 메모리를 매핑 -> 충돌은 적지만 모든 블록을 탐색해야 해서 속도가 느리다.  
- **집합 연관 매핑**(Set associative mapping) : 두 매핑 방식을 합친 방법으로, 순서는 일치시키지만 집합을 둬서 저장하고 블록화되어 있기 때문에 검색이 효율적이다.  

<br>

**웹 브라우저 캐시**  
- **쿠키**(Cookie) : 만료기한이 있는 키-값 저장소로, 4KB까지 데이터를 저장할 수 있다.  
- **로컬 스토리지**(Local Storage) : 로컬 저장소에 저장되는 키-값 저장소로, 10MB까지 저장할 수 있다.  
- **세션 스토리지**(Session Storage) : 웹 브라우저의 탭 단위로 세션을 설정하는 키-값 저장소로, 5MB까지 저장할 수 있다.  

<br>

**데이터베이스의 캐싱 계층**  
- **앱**(Application) - **메인 데이터베이스**(DB) 사이에 캐시 DB인 **Redis**를 ‘캐싱 계층’으로 두어 성능을 향상  

<br>

※ 캐싱(Caching)은 **복사본**을 이용하는 것이다.  
복사본과 원본이 달라지는 경우가 발생할 수 있으니 **일관성 유지**에 유의  

<br>
<br>

### 메모리 관리  

### **가상 메모리**(Virtual Memory)  
> 메모리 관리 기법 중 하나로, 이용 가능한 메모리를 추상화 하여 실제 메모리가 아닌 가상 메모리를 활용할 수 있게 하는 방식  

<img width="1280" height="720" alt="img1 daumcdn" src="https://github.com/user-attachments/assets/26893b6e-6d7a-49d7-b335-e689a10b8c11" />

- CPU가 활용하는 **논리적 주소**(Logical Address)와 실제 메모리의 **물리적 주소**(Physical Address)를  
  **메모리관리장치**(MMU)가 매핑하여 가상 주소를 실제 주소로 변환한다.  
- 우리가 실행시키는 프로그램은 프로세스 단위로 메모리(RAM)에서 실행된다.  
- 프로세스는 **페이지**(Page) 단위로 관리되며 **페이지 테이블**에 프로세스의 주소 정보를 저장하여 관리한다.  

<br>

- 여러 프로그램/프로세스를 동시에 실행하여 메모리(RAM)의 공간을 초과한 경우, 외부 저장장치의  
  스왑영역(Swap Area)을 메모리 공간의 확장 영역으로 사용한다.  

<img width="1182" height="527" alt="스크린샷 2026-02-02 04 37 36" src="https://github.com/user-attachments/assets/f1ffa68f-1821-43a2-a46e-14b740dda6ae" />

**페이지 폴트**(Page Fault)  
> CPU가 메모리(RAM)에 있는 프로세스에 접근했을 때, 원하는 데이터/페이지가 없는 경우 발생

<img width="620" height="315" alt="스크린샷 2026-02-02 04 19 45" src="https://github.com/user-attachments/assets/262f7177-f9ca-41d6-b00a-fcff84ac4f8a" />

- 페이지 폴트 발생 시,  메모리(RAM)에 여유 공간을 확인하고, 여유 공간이 없을 시 외부 저장장치(Disk)의 스왑 영역(Swap Area)에서 페이지를 찾아 스와핑(Swapping) 한다.  
- 스왑 영역(Swap Area)은 외부 저장장치(Disk)에 존재하기 때문에 스와핑(Swapping) 발생 시,  
  운영체제에 의해 Swap I/O 작업이 발생한다.  
- 공간 효율성보다 **시간 효율성**을 고려한 저장으로 일반적으로 파일 시스템에 접근하는 것보다 빠른 접근이 가능하다.  

<br>

 **스와핑 과정**  
1. CPU에서 물리 메모리(RAM)에 접근하여 필요한 페이지를 찾고, 없을 시 운영체제 호출  
2. 운영체제는 CPU의 동작을 일시 정지  
3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인, 없을 시 물리 메모리에  
   여유 공간이 있는지 확인하고, 없다면 스와핑 발동  
4. CPU 재실행  

<br>

**스레싱**(Thrashing)  
> 메모리(RAM)의 페이지 폴트율이 높은 것을 의미하며, 컴퓨터에 큰 성능 저하를 초래  

<img width="711" height="351" alt="IMG_0052-removebg-preview" src="https://github.com/user-attachments/assets/f8c35577-1859-4b8c-b40b-c67990256918" />

- 메모리(RAM)에 동시에 많은 프로세스가 올라가면 스와핑(Swapping) 빈도가 높아지며 발생  
- 페이지 폴트 발생 시 CPU 이용율이 낮아지기 때문에 운영체제는 CPU 가용성을 높이기 위해 더 많은  
  프로세스를 메모리에 할당하며 악순환으로 스레싱이 발생한다.  
- 사용자는 동시에 사용하는 프로세스를 줄이거나 물리적 메모리를 증설하여 해결할 수 있고,  
  운영체제는 **PFF**(Page Fault Frequency) 기법으로 페이지 폴트 빈도의 상한선과 하한선을 만들어,  
  상한선에 도달할 경우, 프레임을 늘리고 하한선에 도달할 경우, 프레임을 줄여 해결할 수 있다.  

<br>

※ 프레임(Frame) : 실제 메모리를 사용하는 최소 크기 단위  

<br>
<br>

### 메모리 할당  

**연속 할당**  
> 메모리에 **연속적으로** 공간을 할당하는 방법  

<img width="599" height="416" alt="IMG_0053-removebg-preview" src="https://github.com/user-attachments/assets/2f570f20-5f38-4f49-b951-e6f1d962f1f0" />

- **고정 분할 방식** : 메모리를 고정된 크기로 미리 나누어 관리하는 방식  
  - 메모리를 나눈 크기보다 프로그램이 **작아서** 들어가지 못하는 공간이 발생하는 **내부단편화**가 발생  

- **가변 분할 방식** : 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용하는 방식  
  - 메모리를 나눈 크기보다 프로그램이 **커서** 들어가지 못하는 공간이 발생하는 **외부단편화**가 발생  
  - **최초적합** : 시작지점에서 할당할 수 있는 비어있는 메모리 공간이 생기면 바로 할당  
  - **최적적합** : 프로세스 크기 이상의 공간 중 가장 작은 공간부터 할당  
  - **최악적합** : 프로세스의 크기와 차이가 가장 많이 나는 공간부터 할당  

<br>

  <img width="444" alt="image 2" src="https://github.com/user-attachments/assets/251dbf54-510f-443d-b37a-ab359a70dc72" />

<br>
<br>

**불연속 할당**  

- **페이징**(Paging) : 메모리를 동일한 크기의 **페이지(일반적으로 4KB) 단위**로 나누고, 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당하는 방식  

- **세그멘테이션**(Segmentation) : 의미 단위인 **세그먼트(Segment)**로 나누는 방식으로, 코드 영역,  
  데이터 영역, 스택 영역, 힙 영역으로 이루어진 프로세스 메모리를 코드 + 데이터로 나누거나, 코드 내  
  작은 함수를 세그먼트로 놓고 나눌 수도 있다.  
  - 보안 측면에서 장점을 가지지만 **가용 메모리 공간의 크기**가 균일하지 않음  

- **페이지드 세그멘테이션**(Paged Segmentation) : 프로그램을 의미 단위인 세그먼트로 나눠 보안 측면에 강점을 두지만, **가용 메모리 공간을 임의의 길이가 아닌 동일한 크기의 페이지 단위**로 나누는 방법  
  
<br>

### 페이지 교체 알고리즘  
> 한정된 메모리 공간을 효율적으로 스와핑(Swapping) 하기 위한 방법을 정의한 알고리즘  
> (많이 일어나지 않는 방향으로)  
  
- **FIFO**(First In First Out) : 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법  

- **LRU**(Least Recently Used) : 가장 오랫동안 사용하지 않는 페이지를 교체하는 방법  
  - 가장 오래된 것을  파악하기 위해 각 페이지마다 계수기, 스택을 두어야 하는 단점 존재  

- **NUR**(Not Used Recently) : LRU에서 발전한 알고리즘으로 각 페이지마다 0, 1 비트를 두고 시계 방향으로 돌면서 0을 찾아 프로세스를 교체하고 해당 부분을 1로 바꾸는 알고리즘  

- **LFU**(Least Frequently Used) : 사용 횟수가 가장 적은 페이지를 교체하는 방법  
