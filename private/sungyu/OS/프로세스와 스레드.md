# 프로세스와 스레드  
### 프로세스와 컴파일 과정  

**프로그램**(Program)  
> 컴퓨터가 실행할 수 있는 명령어들의 집합  

ex) 구글 크롬 프로그램(chrome.exe) 실행파일  

<br>
<br>

**프로세스**(Process)  
> 컴퓨터에서 실행 중인 프로그램  
> 각각의 프로세스는 **독립된** 메모리 공간을 할당 받는다.  

**스레드**(Thread)  
> CPU에서 실행되는 단위로, 프로세스 내 작업 흐름을 의미  

**프로그램 실행 과정**  
1. HDD/SSD - 프로그램이 인스턴스화가 일어나며 메모리(RAM)에 올라간다.  
2. CPU - 운영체제 CPU 스케줄러에 따라 프로세스를 실행

**컴파일**(Compile)  
> 사람이 작성한 소스코드를 CPU가 이해하고 실행시킬 수 있는 기계어로 변환하는 과정  


**컴파일 과정**  
1. **전처리** : 소스 코드에서 주석을 제거하고 # include 등 헤더파일을 병합하여 매크로를 치환  
2. **컴파일러** : 오류 처리, 코드 최적화 작업을 하여 어셈블리어로 변환  
3. **어셈블러** : 어셈블리어를 목적 코드(Object Code) 로 변환하여 Object File 생성 (파일형식.o)  
4. **링커** : 프로그램 내 라이브러리 함수 또는 다른 파일들과 목적 코드를 결합하여 실행 파일을 생성   
   (파일형식.exe/파일형식.out)  

<br>
<br>

### 프로세스의 상태  

**생성 상태**  
> fork() 또는 exec() 함수를 통해 프로세스가 생성된 상태. PCB가 할당한다.  

※ fork() : 프로세스를 복사하여 자식 프로세스를 생성하는 함수  
※ exec() : 새롭게 프로세스를 생성하는 함수  

**준비 상태(대기)**  
> 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기하며 CPU 스케줄러로부터 CPU 소유권을 기다리는 상태  

**대기 중단 상태**  
> 메모리 부족으로 프로세스가 일시 중단된 상태  

**실행 상태**  
> CPU 소유권과 메모리를 할당받고 프로세스의 명령을 수행 중인 상태  

**대기 상태(중단)**  
> 어떤 이벤트 발생 이후, 기다리면서 프로세스가 차단된 상태  
ex) 프린트 인쇄 버튼 클릭 시, 프로세스가 잠깐 멈추는 상태 (I/O 디바이스에 의한 인터럽트 현상)  

**일시 중단 상태**  
> 대기 중단 상태와 유사하게 중단된 상태에서 프로세스가 실행되려다 메모리 부족으로 일시 중단된 상태  

**종료 상태**  
> 메모리와 CPU 소유권을 모두 놓고 가는 상태  
ex) process.kill  

<br>
<br>

### 프로세스의 메모리 구조  

**스택 영역**  
- 동적으로 할당되는 영역  
- **지역 변수**, **매개 변수**, **리턴 값** 등 잠시 사용하고 사라지는 데이터를 저장하는 영역  

**힙 영역**  
- 동적으로 할당되는 영역  
- 메모리 주소값에 대해서만 참조되고 사용되는 영역  

**데이터 영역**  
- 정적으로 할당되는 영역  
- **전역 변수**와 **정적 변수**가 저장된다. (프로그램 시작 시 할당, 프로그램 종료 시 소멸)  

**코드 영역**  
- 정적으로 할당되는 영역  
- 실행할 프로그램의 **코드**가 저장되는 영역으로 CPU가 코드 영역에서 명령어를 하나씩 가져와 실행  

<br>
<br>

### PCB(Process Controll Block)  
> 운영체제에서 프로세스에 대한 **메타 데이터**를 저장한 데이터  

- 프로세스가 생성될 때 운영체제는 PCB를 생성  
- 프로세스 완료 시 PCB는 제거된다.  

- **프로세스 스케줄링 상태** : ‘준비’, ‘일시중단’ 등 프로세스가 CPU 소유권을 얻은 이후의 상태  
- **프로세스 ID** : 프로세스 ID, 해당 프로세스의 자식 프로세스 ID  
- **프로세스 권한** : 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보  
- **프로그램 카운터** : 프로세스에서 실행해야 할 다음 명령어의 주소에 대한 포인터  
- **CPU 레지스터** : 프로세스르르 실행하기 위해 저장해야 할 레지스터 정보  
- **CPU 스케줄링 정보** : CPU 스케줄러에 의해 중단된 시간 등 정보  
- **계정 정보** : 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보  
- **I/O 상태 정보** : 프로세스에 할당된 I/O 디바이스 목록  

<br>

**컨텍스트 스위칭**(Context Switching)  
> CPU에서 실행 중인 프로세스가 다른 프로세스/스레드로 교체되는 것  

- 프로세스에 할당된 시간이 만료되거나 인터럽트에 의해 발생  
- I/O 작업 시, 또는 다른 리소스를 기다려야 하는 상황에 발생  
- **커널**(Kernel)이 컨텍스트 스위칭을 관장  
- CPU의 레지스터 상태를 교체하는 방식  
- 스위칭 시 프로세스의 PCB(메타 데이터)를 저장하고 로드하는 유휴 시간(Idle time)이 발생  
- 캐시 미스(Cache Miss)에 따른 **캐시 오염**(Cache Pollution) 발생  

<br>

**프로세스 컨텍스트 스위칭**(Process Context Switching)  
> 다른 프로세스끼리의 스위칭  

- 가상 메모리 주소 관련 처리를 추가로 수행(MMU, TLB 초기화)  


**스레드 컨텍스트 스위칭**(Thread Context Switching)  
> 같은 프로세스의 스레드들 간의 스위칭  

- 스레드는 스택 영역을 제외한 모든 영역의 메모리를 공유하기 때문에 메모리 교체 비용이 적고,  
  더 적은 시간이 소요된다.  

<br>
<br>

### 멀티프로세싱  
> 여러 개의 프로세스를 통해 동시에 두 가지 이상의 일을 수행하는 것  

ex) **웹 브라우저**  
- **브라우저 프로세스** : 주소 표시줄, 북마크, 뒤로가기/앞으로 가기 버튼 담당하며 네트워크 요청이나 파일 접근 권한 담당  
- **렌더러 프로세스** : 웹 사이트에서 보이는 부분의 모든 것을 제어  
- **플러그인 프로세스** : 웹 사이트가 사용하는 플러그인을 제어  
- **GPU 프로세스** : GPU를 이용해서 화면을 그리는 부분을 제어  

<br>

### 스레드와 멀티스레딩  

**스레드**(Thread)  
> 프로세스의 실행 가능한 가장 작은 단위  

- 프로세스는 코드, 데이터, 스택, 힙 영역을 각각 생성하지만,  
  스레드는 코드, 데이터, 힙 영역은 스레드끼리 공유하고, 스택 영역반 별도로 존재  

<img width="597" height="418" alt="IMG_0121-removebg-preview" src="https://github.com/user-attachments/assets/f03d8764-c203-4d0a-8444-0e382631c8e2" />

<br>

**멀티스레딩**(Multi Threading)  
> 프로세스 내 작업을 여러 개의 스레드, 멀티스레드로 처리하는 기법  

- 스레드 간 자원을 공유하기 때문에 효율성이 높다.  
- 웹 요청을 예시로 들 때 새 프로세스를 생성하는 것이 아닌 스레드를 사용해 훨씬 적은 리소스를 소비한다.  
- 한 스레드가 중단(Blocked) 되어도 다른 스레드는 실행(Running) 상태일 수 있기 때문에 중단 없이 빠른 처리가 가능  
- 한 스레드에 문제가 생기면 다른 스레드에 영향을 끼쳐 프로세스에 영향을 줄 수 있는 단점 존재  

ex) **웹 브라우저의 렌더러 프로세스** : 메인 스레드, 워커 스레드, 컴포지터 스레드, 레스터 스레드로 구성  

<br>

### 공유 자원과 임계 영역  

**공유 자원**(Shared resource)  
> 시스템 안에서 각 프로세스/스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원  

**경쟁 상태**(Race condition)  
> 공유 자원(Shared resource)을 두 개 이상의 프로세스/스레드 가 동시에 읽거나 쓰는 상황  

- 공유 자원의 일관성, 프로세스/스레드 처리 결과가 달라져 **일관성**을 보장할 수 없는 문제가 발생  


**임계 영역**(Critical section)  
> 공유 데이터의 일관성을 보장하기 위해 하나의 프로세스/스레드만 진입해서 실행 가능한 영역  

- 임계 영역과 관련한 문제 해결을 위해서는 상호 배제(Multual Exclusion), 한정 대기(Bounded Waiting), 진행(Progress) 조건을 만족해야 한다.  
- **상호 배제**(Multual Exclusion) : 한 번에 하나의 프로세스만 임계 영역에 접근 가능하다.  
- **한정 대기**(Bounded Waiting) : 특정 프로세스가 임계 영역에 무한히 대기하다가 들어가지 못하면 안된다.  
- **진행**(Progress) : 임계 영역을 하나의 프로세스가 사용 중이라면 작업을 진행할 수 있게 다른 프로세스가 방해하면 안된다.  
- **스핀락**(Spin Lock), **뮤텍스**(Mutex), **세마포어**(Semaphore) 등 동기화를 통해 해결 가능하다.  

<br>

### 교착 상태(Deadlock)  
> 두 개 이상의 프로세스/스레드들이 서로가 가진 리소스를 기다리며 중단된 상태  

<img width="600" height="621" alt="image" src="https://github.com/user-attachments/assets/433e8384-a1b3-4ba4-911c-e3e3915a34a0" />

<br>
<br>

**교착상태의 4가지 조건/원인**  
1. **상호 배제**(Multual Exclusion) : 리소스를 공유해서 사용할 수 없다.  
2. **점유 대기**(Hold and Wait) : 프로세스가 하나 이상의 리소스를 점유한 상태에서 다른 프로세스의 리소스를 기다리는 상황  
3. **비선점**(No Preemption) : 다른 프로세스의 자원을 강제적으로 가져올 수 없다.  
4. **환형 대기**(Circular Wait) : 프로세스들이 순환 형태로 서로의 리소스를 기다리는 상황  

**해결 방법**  
1. **데드락 방지** : 교착 상태의 조건 중 하나의 조건을 충족하지 않도록 시스템을 디자인  
   - 리소스를 공유 가능하게 함 (현실적으로 불가)  
   - 사용할 리소스를 모두 획득한 뒤 시작  
   - 추가적인 리소스를 기다려야 한다면 이미 획득한 리소스를 다른 프로세스가 선점 가능하도록 양보  
   - 모든 리소스에 순서 체계를 부여해서 오름차순으로 리소스를 요청  
2. **데드락 회피** : 실행 환경에서 추가적인 정보를 활용해서 데드락이 발생할 것 같은 상황을 회피하는 것 (Banker Algorithm)  
3. **데드락 감지와 복구** : 데드락을 허용하고 데드락이 발생하면 복구하는 전략  
   - 프로세스 강제 종료  
   - 리소스의 일시적인 선점을 허용  
