# 인덱스

### 인덱스(Index)란?  
> 데이터베이스에서 저장공간을 활용하여 테이블 검색 속도를 향상시키기 위한 자료구조  

<img width="531" alt="image" src="https://github.com/user-attachments/assets/0a589e56-3d78-479e-a1ef-53ddadd3d73d" />


### 인덱스(Index)의 필요성  

**두꺼운 책에서 특정 내용을 찾을 때**, 모든 내용을 순차적으로 찾아본다면 많은 시간이 소요된다.  
이때 **도서의 목차 또는 색인을 활용**하면 더 빠르고 효율적으로 정보를 찾을 수 있다.  

마찬가지로 데이터베이스에서도 **인덱스**를 활용한다면 전체 데이터를 조회(Full Scan)할 필요 없이,  
빠르고 효율적으로 특정 데이터에 접근할 수 있다.  

- 찾고자 하는 데이터를 빠르게 조회(SELECT) 할 수 있다.  
- 빠른 정렬(ORDER BY) 또는 그룹핑(GROUP BY)이 가능하다.  

<br>
<br>

**해시 인덱스**(Hash Index)  
> 해시 테이블 (Key-Value)을 사용하여 구현한 인덱스(Index)  

- 데이터 조회(SELECT) 시, **시간복잡도 O(1)**의 성능으로 굉장히 빠르다.  
- 해시 테이블 사이즈 확장 (Rehashing)에 대한 부담이 있다.  
- 해시가 등호(=) 연산에 특화되어있기 때문에 ~**부등호 연산(<, >)을 활용한 범위 연산이 불가능**~하다.  
- 여러 컬럼을 인덱스로 구성하는 경우(Multicolumn index) 특정 컬럼에 대해 조회가 불가능하다.  
  (다중컬럼 인덱스에서는 전체 컬럼에 대한 조회만 가능)  

→ 성능면에서 장점이 있지만 치명적인 제약사항이 있어 일반적으로 **B-Tree 기반 인덱스**를 사용  
 
<br>

**B-Tree 기반 인덱스**(B-Tree Index)  
> 이진 탐색 트리(Binary Search Tree)를 확장한 형식의 B-Tree를 활용하여 구현한 인덱스(Index)  

- 데이터 조회(SELECT) 시, **시간복잡도가 O(logN)** 이다.  
- 트리의 높이/깊이가 낮아 디스크 접근 횟수가 감소하여 성능면에서 유리하다.  

<br>

**Full Scan이 더 좋은 경우**  
- 데이터 양이 적을 때  
- 조회할 데이터가 테이블의 상당 부분을 차지할 때  

<br>
<br>

### B-트리  
> 이진 탐색 트리(Binary Search Tree)에서 자녀 노드의 개수, 하나의 노드가 가질 수 있는 값 등을  
> 확장한 형태의 자료구조  

**이진 탐색 트리**(Binary Search Tree)  
<img width="246" height="205" alt="image 2" src="https://github.com/user-attachments/assets/ae34b039-d642-48dc-bb44-8ab37053b0f5" />

- 하나의 노드가 가질 수 있는 **자식 노드의 최대 갯수는 2개**  
- 좌측 자식 노드에는 부모 노드보다 작은 값, 우측 자식노드에는 부모 노드보다 큰 값 배치  


**B-트리**(Balanced Tree)  

<img width="392" alt="image 3" src="https://github.com/user-attachments/assets/377011d4-e8dd-46f6-a417-739d6508c7f7" />

- 부모 노드의 키(Key) 개수에 따라 **자식 노드의 최대 개수가 결정**된다.  
  (-> 최대 M개의 자식을 가질 수 있는 B-Tree를 M차 B-Tree 라 부른다.)  
- 부모 노드의 키(Key) 값은 항상 오름차순으로 정렬  
- 정렬된 부모 노드의 키(Key)에 따라 자식 노드들의 키(Key) 값의 범위가 결정된다.  
- 데이터의 추가는 항상 Leaf 노드에서 진행된다.  
- 하나의 노드가 가질 수 있는 키(Key) 의 개수를 초과하면 키의 중앙값을 기준으로 좌우 키들을 분할하고  
  중앙값 키는 승진한다.  

<br>

### 인덱스 만드는 방법  

**< PLAYER >**  
| id  | name | team_id | backnumber |
|:---:|:----:|:-------:|:----------:|
| …   | …    | …       | …          |

<br>

**MySQL**  
- 인덱스 생성  

```sql
CREATE INDEX player_name_idx
ON player(name);

--- CREATE INDEX 인덱스 명
--- ON 테이블(컬럼);
```

```sql
CREATE UNIQUE INDEX team_id_backnumber_idx
ON player(team_id, backnumber);

--- CREATE UNIQUE INDEX 인덱스 명
--- ON 테이블(컬럼1, 컬럼2, ...);
```

<br>

- 테이블 생성 시 인덱스 설정  

```sql
CREATE TABLE player (
	id	int PRIMARY KEY,
	name VARCHAR(20) NOT NULL,
	team_id INT,
	backnumber	INT,
	INDEX player_name_idx (name)
	UNIQUE INDEX team_id_backnumber_idx (team_id, backnumber)
);
```

<br>

- **인덱스 조회**  

```sql
SHOW INDEX
FROM user_user;
```

<br>

- 실제 쿼리문에 적용되고 있는 **인덱스 조회** (EXPLAIN)  

```sql
EXPLAIN
SELECT * FROM user_user WHERE student_id like "2020%";
```  

※ 기본키(Primary Key)에는 인덱스(Index)가 자동 생성된다.  

<br>

### 인덱스 최적화 기법  

- 인덱스(Index)는 항상 **정렬된 상태**로 유지해야 원하는 값을 빠르게 찾을 수 있다.  
- 데이터가 변경될 때, 인덱스도 함께 변경하여 **최신 상태를 유지**해야 한다.  
  - 데이터 추가 시 (INSERT), 새로운 데이터에 대한 인덱스 추가  
  - 데이터 삭제 시 (DELETE), 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업  
  - 데이터 수정 시 (UPDATE), 기존 인덱스를 사용하지 않음 처리 하고, 갱신된 데이터를 인덱스에 추가  

- 사용되는 쿼리에 맞춰 적절하게 인덱스(Index)를 걸어줘야 쿼리가 빠르게 처리될 수 있다.  
- Covering Index를 활용하는 방법 (조회 성능 향상)  

  **< INDEX(team_id, backnumber) >**

  | team_id | backnumber | ptr |
  |:-------:|:----------:|:---:|
  | …       | …          | …   |

  ```sql
  SELECT team_id, backnumber
  FROM player 
  WHERE team_id = 5;
  ```
