# Worker Time out 문제 해결 방안

### Worker

Worker는 OS와 관련된 개념이 아닌 프레임워크에서 사용하는 개념이다.

프레임워크/Worker는 프로세스와 스레드와 유사한 부분이 있기 때문에 기본 개념인 OS의 프로세스와 
스레드를 이해할 필요가 있다.

### OS 프로세스와 스레드의 이해

- 프로그램이란?
    
    메모리를 할당 받지 못한 정적 파일을 의미한다.
    
    프로그램은 메모리를 할당 받음으로써 역할을 수행 할 수 있다.
    
- 프로세스란?
    
    프로그램과 동일한 위치에 있다고 보면 된다.
    
    OS 스케쥴러에서 프로그램을 실행하라는 명령을 받고 메모리를 할당하여 프로그램을 실행시킬 때
    
    프로세스가 할당된다고 표현된다.
    
    컴퓨터가 여러 활동을 동시에 실행하기 위해서 프로세스를 통해 활동을 나눠서 움직인다.
    
    메모리를 할당 받았기 때문에 각기 다른 프로세스간 이동은 불가능한 것이 기본이지만, 특정 경우에는 컨텍트 스위칭 비용을 감안하고 데이터 이동이 가능하다.
    
    안정성 높다/비효율적
    
- 스레드
    
    OS에서 프로세스로 나눈 것처럼 스레드 또한 프로세스 안에서 효율적인 분산을 위해서 스레드로 분리시켜놓았다.
    
    프로세스와는 다르게 스레드는 같은 메모리(프로세스)안에서 동작하는 활동이다보니 각기 다른 스레드끼리 이동이 원활하다.
    
    메모리를 공유해서 활동하기 때문에 효율적이다.
    
    위험성 높다/효율적
    

### 프로세스와 Worker의 관계

프로세스는 OS에서 기본 메모리를 통해서 할당하는 것이고, Worker는 위에서 설명했던 것과 같이 프레임워크 내부에서 효율적인 사용을 위해서 일꾼을 나눠놓았다고 생각하면 된다.

고로 프로세스, 스레드, Worker의 관계는 아래 도표로 설명할 수 있다고 생각했다

```c
프로세스
 └─ 스레드
      ├─ gunicorn worker
      ├─ gunicorn worker
      └─ gunicorn worker
```

하지만 worker는 프로세스와 같은 개념이라고 볼 수 있다고 말한다

프로세스는 말 그대로 메모리를 할당받은 프로그램이라고 말할 수 있는데, 프로그램은 여러 프로세스를 사용하여 하나의 프로그램을 돌리게 만들 수 있다. 
Django를 예시로 든다면 Django를 실행하기 전에 gunicorn이라는 웹 서버 프로그램을 실행하게 되고

gunicorn이 가지고 있는 여러 Worker를 각기 다른 프로세스에서 실행함으로써 효율적인 동기적 사용이 가능하다

아래 도표로 이해할 수 있다.

```c
[OS]
 └─ Django uploadpdf 프로세스(gunicorn worker)
		 └─ 스레드
		      ├─ uploadpdf_Textout
		      ├─ uploadpdf_yearout
		      └─ uploadpdf_semesterout
      
		Django login 프로세스(gunicorn worker)
		 └─ 스레드
		      ├─ uploadpdf_Textout
		      ├─ uploadpdf_yearout
		      └─ uploadpdf_semesterout
      
		DB 프로세스(gunicorn worker)
		 └─ 스레드
		      ├─ select...
		      
#독립 실행 단위일 뿐
#API요청만을 프로세스로 나눈것이 아님
```

### 결론 : Worker Time out은 어떤 오류인가?

gunicorn을 여러 프로세스를 사용하여 nginx에서 보낸 요청을 효율적으로 해결한다.

이때 Worker 즉, 하나의 프로세스가 긴 로딩시간, 잘못된 외부API 등의 요소들로 인해 기본 설정된 30s이상을 넘어가게 되면 잘못된 요청이라 판단하여 프로세스 자체를 꺼버리게 되는 오류가 발생한다.

그렇기에 만약 해당 프로세스가 사용자가 요청한 API라면 큰 UX오류를 범하게된다.

그래서 Django middleware.py를 만들어서 Django에게 전달되는 API마다 시간을 계산하여 긴 요청시간을 가진 API를 찾아내어 우선적으로 요청시간을 개선해내고

그 외의 문제점을 찾아내어 끝에서는 동시성 문제를 해결하고 싶다.

**참고문헌**

https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4