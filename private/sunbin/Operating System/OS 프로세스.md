# OS 프로세스

> **프로그램**
> 

프로그램은 실행 가능한 파일을 일컬는다

소스코드가 실행 가능한 파일로 바뀌면서 하드 디스크에 저장되어있다

사용자가 프로그램인 exe파일을 실행시키면 OS 스케줄러에 의해 메모리에 올라간다

이때 프로그램이 바이너리화 되어 메모리에 영역을 차지하면 프로세스라 불리운다.

> **컴파일 과정**
> 

위 설명과 같이 프로그램은 소스파일을 실행가능한 파일로 변경될 때 부르는 명칭이다

소스파일을 실행가능하게끔 변경시켜주는 것이 컴파일 과정이다

자세한 컴파일 과정은 다음과 같다

소스 코드 파일- 전처리 - 어셈블리화 - 링커 - 실행 가능한 파일(프로그램/확장자 exe)

> **프로세스**
> 

프로세스는 메모리에 올라간 실행중인 프로그램이다

OS가 CPU에게 할당해주는 가장 최소 단위의 작업(Task)이다.

**가장 최소 단위는 스레드도 존재하는데 왜 최소단위라고 말하는지?

현재 이전에는 프로세스가 가장 작은 단위의 작업(Task)이 맞았으나
컴퓨터의 발전 이후 스레드가 만들어지면서 가장 작은 단위는 스레드가 맞다
CPU스케줄러에서 실제로 CPU에게 전달해주는 것은 프로세스가 아닌 프로세스안의 스레드다

> **프로세스 상태**
>

<img width="879" height="387" alt="스크린샷_2026-02-05_030503" src="https://github.com/user-attachments/assets/376e0ee0-61dd-4e03-8357-8ff7106fbb1b" />

> **생성 상태**
> 

프로그램이 프로세스로 올라가는 상태이다

프로그램이 실행되어 메모리에 올라가는 과정에서 OS가 커널영역의 PCB를 생성한다

커널 영역의 PCB가 생성되면 프로그램이 프로세스로 변경된 상태이다

PCB가 생성된 때에는 이미 메모리에 올라가 있는 상태로 이때 준비 상태로 넘어간다

이때 커널 영역이란 OS 내부에서 사용자 영역과 분리된 영역이다

사용자 영역은 실제 사용자가 사용하는 OS 내부의 프로그램, 어플리케이션이 들어있다

커널 영역은 사용자가 사용하면 안되는 시스템 자원들이 존재한다

영역을 분리시켜 놓음으로써 사용자가 시스템 자원에 접근하는 것을 막는다

사용자 영역 → 커널 영역 직접 접근은 불가능 하지만 커널 영역 → 사용자 영역으로 

직접 접근하는 것은 가능하다

그렇기에 PCB가 커널영역에 위치해 있더라도 사용자 영역의 프로그램에 접근할 수 있다

> **준비 상태**
> 

메모리에 올라가 있는 프로세스가 CPU에 할당되는 것을 기다리는 상태를 준비 상태라고 한다

OS가 CPU에 할당하도록 정하는 것을 CPU스케줄링이라고 한다

callback X

> **실행 상태**
> 

메모리에 있는 프로세스가 CPU에 할당되는 것을 실행 상태라고 불리운다

이때 CPU **코어** 하나당 가질 수 있는 프로세스는 1개이다

OS 스케줄러에 의해 프로세스가 CPU를 빼앗길 수도 있다

CPU에서 입/출력 상태가 되면 프로세스가 대기 상태로 변경되어 

다른 프로세스 작업을 받을 수 있다

> **대기 상태**
> 

CPU에서 받은 작업이 입/출력이거나 바로 작업할 수 없는 내용이라면 CPU를 반납하고

대기 상태로 변환하여 대기한다

요청한 일이 완료되면 다시 실행 상태로 변경된다

callback O

> **종료 상태**
> 

프로그램이 종료되면 프로세스에서 받은 자원들을 반납한다. 이때 PCB를 제외한 모든 자원들이 없어지고

OS에서 더이상 사용하지 않는다는게 명확해지면 PCB마저 지우고 이때 프로세스가 완전히 종료된다

> **보류 상태**
> 

잠깐 존재하는 생성 상태, 종료 상태를 제외한 준비, 실행, 대기 상태는 활성 상태(Active State)로 불리운다

활성 상태란 메모리를 일정분량 얻어놓은 상태를 의미한다

이때 메모리가 부족하다면 활성 상태에서 일부분 보류 상태로 내려 부족한 메모리를 회수한다

부족한 메모리를 회수 당하는 것을 swapped out이라고 부른다

다시 돌아오는 것을 swapped in이라고 부른다

이 과정을 스와핑(Swapping)이라고 부른다

> **프로세스 메모리**
> 

프로세스가 할당 받은 메모리를 말한다

> **메모리 구조**
> 

<img width="449" height="612" alt="스크린샷_2026-02-05_030727" src="https://github.com/user-attachments/assets/8f3f1853-d0c3-40be-8977-bed4f6186418" />


- Stack
    
    코드에서의 **지역 변수, 매개 변수**가 **들어가는 공간**이다
    
    메모리에서 가장 위에 존재하고 있다
    
    스택은 주소값이 큰쪽에서 작은 쪽으로 생성된다.
    
    이때 스택이 점점 쌓여 메모리를 초과하게 되는 경우가 생기는데
    
    이때를 스택 오버플로우라고 부른다 ⇒ 정적, 동적
    
    동적 메모리 크기 늘림 - 초과하지 않나 - 한계점안에서
    
    Stack Frame은 함수가 새로 생성될 때마다 해당 함수의 변수를 저장하는 공간이다
    
    두 함수가 실행되면 Stack Frame이 두개로 증가하게 되고 하나의 함수가 return하면
    
    Stack Frame이 사라진다
    
   <img width="688" height="552" alt="스크린샷_2026-02-05_030541" src="https://github.com/user-attachments/assets/fb43b03f-ff89-4eb4-b6eb-780e57ba27f2" />

    
    ```java
    [ bar 스택 프레임 ]
    - 매개변수
    - return address
    - 지역 변수 b
    -------------------
    [ foo 스택 프레임 ]
    - 매개변수
    - return address
    - 지역 변수 a
    ```
    
- Heap
    
    힙은 프로세스의 사용자 영역에 존재하는 메모리 공간으로,
    
    같은 프로세스에 속한 모든 스레드가 접근할 수 있다.
    
    힙 메모리는 실행 중에 OS에게 요청하여 할당되며,
    
    컴파일 타임에 크기와 수명이 정해지지 않고
    
    런타임에 동적으로 결정된다.
    
    힙 메모리는 할당과 해제 시 시스템 콜을 통해
    
    커널의 메모리 관리자를 거치기 때문에
    
    스택에 비해 관리 비용이 큰 편이다. ⇒ 동적
    
    ```java
    int *heap_var = new int(10);
    ```
    
- Data
    
    전역 변수, 정적 변수등이 저장되어 있는 공간이다
    
    프로그램 시작시 할당되어 종료시 까지 가지고 있는다 ⇒ 정적
    
    ```java
    int global_var = 42; 
    static int init_var = 28;
    ```
    
- Code(Read-Only)
    
    const같이 절대 변경되지 않는 상수 변수가 **저장 되어 있는 공간**이다
    
    인간이 쓴 코드가 존재하는 공간이다
    
    컴파일시에 결정되고 바뀔 수 없다 CPU가 실행할 수 있도록 기계어 명령 형태로 변환 되어 있다.
    
    ```java
    void func() {
        // 실행 로직
    }
    ```
    

> **PCB(Process Control Block)**
> 

운영체제가 프로세스를 관리하기 위해 정보를 저장해 놓은 공간

커널 영역에서 만들어져 커널의 주기억장치에서 유지된다

이전 설명처럼 메모리에 올라갈 때 OS에서 PCB를 만들어 놓으면 그때 프로세스가 실행 되었다

라고 말한다 프로세스 종료 상태에서 PCB가 사라지면 프로세스가 완전히 종료된 것을 의미한다

<img width="333" height="573" alt="스크린샷_2026-02-05_031110" src="https://github.com/user-attachments/assets/7602608b-1bb3-4590-9fa0-538a9f386ff6" />


- Pointer
    
    PCB의 현재 위치를 저장하는 포인터 정보
    
- Process State
    
    프로세스의 현재 상태를 저장한다
    
- Process Number
    
    프로세스 고유 ID가 할당된다
    
- Program Counter
    
    다음 Process에 대한 정보를 저장한다
    
- Register
    
    프로세스의 레지스터 정보를 저장한다
    
- Memory Limits
    
    프로세스가 사용하는 메모리 영역에 대한 정보, 할당된 메모리 위치 등이 저장된다
    
- Open File Lists
    
    프로세스를 위해 열려있는 파일의 리스트
    

그 외에 PCB에 빠르게 접근하기 위해 Process table을 통해 PCB를 관리한다

<img width="782" height="610" alt="스크린샷_2026-02-05_031449" src="https://github.com/user-attachments/assets/3a0ae5cc-6002-428d-86d7-119d30adfd9b" />
