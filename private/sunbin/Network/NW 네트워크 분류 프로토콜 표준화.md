# NW 네트워크 분류/프로토콜 표준화

> **네트워크 분류**
> 

네트워크 규모에 따라 네트워크를 분류할 수 있다

LAN/MAN/WAN

> **LAN**
> 

근거리 통신망을 의미하며 전송 속도가 빠르게 혼잡하지 않다

보통 집, 사무실, 학원 등 상대적으로 좁은 공간에서 사용

> **MAN**
> 

도시 지역 통신망을 의미하며 전송 속도는 보통이며

LAN보다 혼잡하다

> **WAN**
> 

광역 통신망으로 국가나 대륙 단위의 광범위한 지역을 연결한다

전송속도는 낮으며 MAN보다 혼잡하다

> **네트워크 프로토콜 표준화**
> 

다른 장치들끼리 데이터를 주고 받기 위해 설정된 공통된 인터페이스, 약속한 규약

기업이나 개인이 발표하는 것이 아닌 IEEE, IETF같은 표준화 단체에서 결정

> **HTTP(Hyper Text Transfer Protocol)**
> 

서버와 클라이언트가 서로 데이터를 주고 받기 위해 사용되는 통신 규약

웹 문서간에 링크를 통해 연결할 수 있고, 여러 종류의 데이터들을 전송할 수 있다

- HTML, TEXT
- Image, 음성, 영상, 파일
- json, xml
- 그 외 데이터

www.naver.com을 [http://www.naver.com으로](http://www.naver.com으로) 지정하는 것은 데이터 정보 교환 등을 HTTP 통신 규약으로 처리하라는 것으로 의미한다고 볼 수 있다

**HTTP 통신 구조**

<img width="1421" height="356" alt="스크린샷_2026-02-18_225026" src="https://github.com/user-attachments/assets/c807c3f0-67d8-4871-b9be-3f91ea27de7a" />


**HTTP의 무상태성(Stateless)**

무상태란 클라이언트와 서버 사이의 상태를 유지하지 않는다

서버가 이전 요청을 기억하지 않는다

그렇기에 쿠키, 세션, JWT를 통해 상태를 저장해야한다

상태를 정의 해놓지 않기 때문에 서버 확장성이 높다(스케일 아웃)

그러나 지속적으로 클라이언트에서 추가 데이터를 전송해줘야 하기 때문에 메모리 비중이 올라간다

**HTTP의 비연결성(Connectionless)**

서버와 클라이언트간 연결을 지속하지 않는다

수천명이 서비스를 이용해도 브라우저에서 요청한 응답만을 처리하고 네트워크를 끊어 서버의 자원을 효율적으로 관리 할 수 있게한다

TCP/IP 구조를 매번 새롭게 연결해야하므로 시간이 소요된다

현재는 HTTP 지속 연결으로 해결하고 있다

HTTP 지속 연결이란 TCP 요청/응답을 종료시키지 않고

연결시켜놓아 계속 동일한 TCP로 재사용 하는 것을 의미한다

> **TCP - 전송 제어 프로토콜**
> 

IP가 클라이언트와 서버간 통신을 위해 IP주소와 패킷으로 통신을 하게 해주는 것이라면 

TCP는 IP 규칙으로 통신하기 부족하거나 불안정하던 단점을 커버하여 패킷 전송을 제어하여 신뢰성을 보증하는 프로토콜이다

IP주소는 목적지에 가기 위한 주소이고, TCP는 목적지까지 안전하게 갈 수 있도록 여러 정보들을 가지고 있다

TCP는 통신 시작할 때와 종료할 때 서로 준비가 되어있는지를 확인하고 패킷 전송 순서를 정하고 나서 통신을 시작한다.

**TCP 3 Way Handshake**

TCP의 통신 확인 기법

SYN : 접속 요청할 때 보내는 패킷, 가장 먼저 보낸다

ACK : 상대방의 패킷을 받고 잘 받았다고 알려주는 패킷

PSH : 데이터를 즉시 목적지로 보내라는 의미

FIN : 접속 종료를 위한 플래그

<img width="1194" height="1053" alt="스크린샷_2026-02-18_231330" src="https://github.com/user-attachments/assets/d40e29df-ae95-437f-8564-b2f061f0078d" />


1. 클라이언트에서 SYN 패킷 전달(응답을 위해 SYN_SENT상태로 변환)
2. LISTEN 상태의 서버가 SYN을 받고 요청 수락 ACK/SYN 패킷을 전달(SYN_RCVD 상태로 변환하여 클라이언트의 ACK패킷을 대기)
3. 클라이언트가 다시 ACK패킷을 보내, ESTABLISHED상태로 데이터가 통신이 가능
4. DATA를 전송하고 ACK를 못받았다면 데이터를 재전송
5. 클라이언트가 접속을 끊기 위해 CLOSE()함수 호출 → FIN 플래그 전달
6. 서버는 CLOSE_WAIT 상태 변환 후 FIN/ACK 전달
7. 클라이언트에서도 FIN을 받았다는 ACK를 전달
8. 종료
